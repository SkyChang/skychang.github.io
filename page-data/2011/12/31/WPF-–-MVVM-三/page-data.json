{"componentChunkName":"component---src-templates-page-js","path":"/2011/12/31/WPF-–-MVVM-三/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"WPF – MVVM (三)","date":"31 December 2011","author":"Sky Chang","excerpt":null,"tags":["Design Patten","Silveright","WPF"],"coverImage":null},"id":"6a8460cb-ec18-573c-80aa-6b5b57f28a12","html":"<p>做到這邊，我們已經做了很大部分的分離了，但是實際上，我們還有一個地方還沒處理，那就是放在View那邊的邏輯，也就是按下Button時的事件，所以我們這邊再進一步的去處理。</p>\n<h4>移除View裡面的邏輯</h4>\n<p>首先我們先把View裡面的邏輯移除，並把它放到ViewModel裡面去，所以我們先將View裡面的東西移除掉，現在裡面真的是空空沒有東西了。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace WPFMVVM3\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n    }\n}\n</pre>\n<p>接下來我們來看看移到ViewModel產生了甚麼變化。</p>\n<h4>邏輯移到ViewModel</h4>\n<p>到這邊，我相信大家就會產生一個疑問，那View裡面的按鈕按下後，要怎樣去呼叫ViewModel裡面的東西呢??其實我們還是會使用一個Binding的方式，只是這次Binding的是一個ICommand的型別；接下來我們繼續處理ViewModel，這次在ViewModel加了一個ICommand型別的參數UpdateTitleNmae，他會回傳一個實作ICommand的RelayCommand實體，並且傳入兩個方法UpdateTitleExecute,CanUpdateTitleExecute ( 沒錯，不要懷疑，傳入進去的是方法)。等下我們會建立RelayCommand類別，到時候就會看到，另外UpdateTitleExecute這個方法裡面定義著要處理的邏輯，也就是從View搬過來的邏輯；而CanUpdateTitleExecute代表著是否可以執行此方法，因為我們這邊一定都會讓此方法( UpdateTitleExecute )可以動作，所以CanUpdateTitleExecute就直接回傳True。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.ComponentModel;\nusing System.Windows.Input;\n\nnamespace WPFMVVM3\n{\n    //實作InotifyPropertyChanged\n    public class PostsViewModel : INotifyPropertyChanged\n    {\n        public Posts posts{ get; set;}\n\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        //定義一個ICommand型別的參數，他會回傳實作ICommand介面的RelayCommand類別。\n        public ICommand UpdateTitleName { get { return new RelayCommand(UpdateTitleExecute, CanUpdateTitleExecute); } }\n\n        public PostsViewModel()\n        {\n            posts = new Posts { postsText = \"\", postsTitle = \"Unknown\" };\n        }\n\n        public string PostsTitle\n        {\n            get { return posts.postsTitle; }\n            set \n            {\n                if (posts.postsTitle != value)\n                {\n                    posts.postsTitle = value;\n                    RaisePropertyChanged(\"postsTitle\");\n                }\n            }\n        } \n\n        //產生事件的方法\n        private void RaisePropertyChanged(string propertyName)\n        {\n            PropertyChangedEventHandler handler = PropertyChanged;\n            if (handler != null)\n            {\n                handler(this, new PropertyChangedEventArgs(propertyName));\n            }\n        }\n\n        //更新Title，原本放在View那邊的邏輯，藉由繫結的方式來處理按下Button的事件。\n        void UpdateTitleExecute()\n        {\n            PostsTitle = \"SkyMVVM\";\n        }\n\n        //定義是否可以更新Title\n        bool CanUpdateTitleExecute()\n        {\n            return true;\n        }\n    }\n}\n</pre>\n<p>這樣，ViewModel就完成了，接下來是處理RelayCommand。</p>\n<h4>撰寫RelayCommand</h4>\n<p>RelayCommand是實作ICommand的類別，一開始我們就可以看到定義了Func和Action，這兩個就是用來參考到剛剛傳入進來的兩個方法，並進行了一些的處理。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Input;\nusing System.Diagnostics;\n\nnamespace WPFMVVM3\n{\n    public class RelayCommand :ICommand\n    {\n\n        readonly Func<boolean> _canExecute;\n        readonly Action _execute;\n\n        public RelayCommand(Action execute)\n            : this(execute, null)\n        {\n        }\n\n        public RelayCommand(Action execute, Func<boolean> canExecute)\n        {\n            if (execute == null)\n                throw new ArgumentNullException(\"execute\");\n            _execute = execute;\n            _canExecute = canExecute;\n        }\n\n        public event EventHandler CanExecuteChanged\n        {\n            add\n            {\n\n                if (_canExecute != null)\n                    CommandManager.RequerySuggested += value;\n            }\n            remove\n            {\n\n                if (_canExecute != null)\n                    CommandManager.RequerySuggested -= value;\n            }\n        }\n\n        [DebuggerStepThrough]\n        public Boolean CanExecute(Object parameter)\n        {\n            return _canExecute == null ? true : _canExecute();\n        }\n\n        public void Execute(Object parameter)\n        {\n            _execute();\n        }\n    }\n}\n</pre>\n<p>最後，我們必須重新調整XMAL。</p>\n<h4>調整XMAL</h4>\n<p>最後的一個動作，我們將Button的Click屬性拿掉了，改成Command屬性，並將之Binding到ViewModel的UpdateTitleName屬性，就完成了。</p>\n<pre class=\"brush: csharp;\">&lt;Window x:Class=\"WPFMVVM3.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:local=\"clr-namespace:WPFMVVM3\"\n        Title=\"MainWindow\" Height=\"350\" Width=\"525\"&gt;\n    &lt;Window.DataContext&gt;\n        &lt;!-- 實例化PostViewModel --&gt;\n        &lt;local:PostsViewModel /&gt;\n    &lt;/Window.DataContext&gt;\n    &lt;Grid&gt;\n        &lt;Label  Content=\"{Binding PostsTitle}\"    Height=\"28\" HorizontalAlignment=\"Left\" Margin=\"12,12,0,0\" Name=\"label1\" VerticalAlignment=\"Top\" /&gt;\n        &lt;Button Content=\"Button\" Height=\"23\" HorizontalAlignment=\"Left\" Margin=\"145,13,0,0\" Name=\"button1\" VerticalAlignment=\"Top\" Width=\"75\" Command=\"{Binding UpdateTitleName}\" /&gt;\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</pre>\n<p>以上就完成了!</p>\n<h4>結尾</h4>\n<p>到這邊就算是手工打造MVVM的一個段落了，其實現在有許多的Framework可以幫我們處理一些繁雜的事物，但如果能了解原理，我相信會更有幫助，所以這次用了循序漸進的方式，來記錄這些內容，也希望能給大家一點幫助!</p>\n<h4>參考資料</h4>\n<ul>\n<li>\n<p><a href=\"http://www.codeproject.com/KB/WPF/WpfMvvmQuickStart.aspx\">http://www.codeproject.com/KB/WPF/WpfMvvmQuickStart.aspx</a></p>\n<li>[http://www.codeproject.com/KB/WPF/MVVMMadeSimple.aspx](http://www.codeproject.com/KB/WPF/MVVMMadeSimple.aspx)\n<li>[http://www.codeproject.com/KB/WPF/MVVMQuickTutorial.aspx](http://www.codeproject.com/KB/WPF/MVVMQuickTutorial.aspx)\n<li>[http://csharperimage.jeremylikness.com/2010/04/model-view-viewmodel-mvvm-explained.html](http://csharperimage.jeremylikness.com/2010/04/model-view-viewmodel-mvvm-explained.html)\n</li>\n</ul>","excerpt":"做到這邊，我們已經做了很大部分的分離了，但是實際上，我們還有一個地方還沒處理，那就是放在View那邊的邏輯，也就是按下Button時的事件，所以我們這邊再進一步的去處理。 移除View裡面的邏輯 首先我們先把View裡面的邏輯移除，並把它放到ViewModel…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"WPF – MVVM (二)","tags":["Design Patten","Silveright","WPF"]},"fields":{"slug":"/2011/12/29/WPF-–-MVVM-二/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/WPF-–-MVVM-二.md"},"previous":{"frontmatter":{"path":null,"title":"ASP.NET MVC -  Helper Namespace錯誤","tags":["ASP.NET","ASP.NET MVC"]},"fields":{"slug":"/2012/01/09/ASP-NET-MVC-Helper-Namespace錯誤/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/ASP-NET-MVC-Helper-Namespace錯誤.md"}}}}