{"componentChunkName":"component---src-templates-page-js","path":"/2011/12/15/WPF-Dependency-Property-深入探討/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"WPF - Dependency Property 深入探討","date":"15 December 2011","author":"Sky Chang","excerpt":null,"tags":["Silveright","WPF"],"coverImage":null},"id":"5d38eab4-34ca-533b-bf07-f3be0e74d385","html":"<p>一直以來，我都認為Flex和WPF ( Silverlight ) 的架構、模式都差不多，反正就是利用XML進行視覺的排版，然後後面有邏輯程式進行處理，然後一堆類似的容器、Control、和事件傳遞模式。</p>\n<p>沒錯，後來深深的發現，我錯了QQ，WPF的架構比Flex的架構深的多，並不是說Flex不好，而是深入地去瞭解WPF後，發現兩者的差異其實很大的，其中一個就是Dependency Property。</p>\n<h4>Property</h4>\n<p>談Dependency Property之前，我們先談談Property，中文稱之為屬性，其實簡單的理解，就例如TextBlock的FontSize，裡面存放著字型的大小，而這種程式碼在XAML裡面可能會這樣寫。</p>\n<pre class=\"brush: xml;\">&lt;TextBlock FontSize=\"12\"/&gt;\n</pre>\n<p>簡單易了解吧，那如果是用Code的方式，可能就會是這樣。</p>\n<pre class=\"brush: csharp;\">TextBlock textBlock = new TextBlock();\ntextBlock.FontSize = 12;\n</pre>\n<p>也滿簡單的，而且，我相信大家一定也都很清楚，但真的是這樣子嗎?讓我們繼續看下去。</p>\n<h4>Property的延續</h4>\n<p>下面是一個WPF的Tree，反正就是簡單的Window下面有DockPanel、StackPanel容器，然後下面又有Button。</p>\n<p><a href=\"http://lh4.ggpht.com/-uKz2hWDTb2U/TujRh73M0kI/AAAAAAAABKI/JeIO44hAMzk/s1600-h/image%25255B8%25255D.png\"><img src=\"http://lh5.ggpht.com/-y1c7aI0wdLQ/TujRil_6HOI/AAAAAAAABKQ/HyxoRIrhloA/image_thumb%25255B4%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>這時候，如果只有在Window下設定FontSize = 12，其他的元件都沒設定FontSize = 12，各位猜，字型會多大多小?</p>\n<p>答案當然是全部都是12，可想而知，下面的元件會延續根的設定，除非元件自己有設定FontSize。</p>\n<h4>解析XML</h4>\n<p>最近在處理一個案子，內容是將XML格式的內容，視覺化出來，其實並沒有想像中的那麼簡單，如上面的那個例子，如果XML最外圈有設定FontSize，內圈都沒有設定FontSize，但是內圈的FontSize若沒有設定，就要沿用外圈的FontSiz，這種程式碼要怎麼寫!?</p>\n<p>好吧，愚蠢的我，當然就是用迴圈的方式，去裡面一個一個比對，然後再針對每個內容進行if的判斷處理。</p>\n<p>如果只顯示一次那還好，但如果要在Run Time時，動態改變字型大小，然後又要調整每個元件的大小，呵呵呵…想翻桌了= =。</p>\n<h4>WPF Dependency Property</h4>\n<p>當然，弄出WPF的團隊，都是神人，自然不會用我這種愚蠢的方法，所以他們用了一個Dependency Property ( 相依屬性 )的架構來解決這種問題，在看Dependency Property之前，我們先看看，以前的Property是怎樣寫的。</p>\n<pre class=\"brush: csharp;\">private double fntsize;\npublic double FontSize\n{\n    get { return fntsize; }\n    set { fntsize = value; }\n}\n</pre>\n<p>老實說，我也是這樣寫的，然後如果FontSize改變的話，可能就去呼叫FontSizeChanged事件…然後…然後…反正就是很麻煩。</p>\n<p>所以WPF使用了Dependency Property，Dependency Property允許以一般的方式進行大部分的通知；那Dependency Property怎樣寫呢?</p>\n<p>第一步就是先用靜態類別定義一個DependencyProperty型態的欄位( C#裡面有欄位這個名詞，不清楚的話可以<a href=\"http://msdn.microsoft.com/zh-tw/library/ms173118.aspx\">參考這裡</a>，但其實就是定義一個變數，但沒有提供存取的方法，而在C#裡面，屬性這個名詞，是有提供存取的方法，這裡特別強調欄位的原因，是因為MSDN裡面，類別的成員，會區分屬性和欄位這兩個名詞，為了方便查找和避免錯亂，所以這裡我就稱為欄位。 )，此外，要注意的一點，這邊設定FontSize這個Dependency Property，那就必須在後面加上Property，所以加上後的欄位名稱就稱為FontSizeProperty。</p>\n<pre class=\"brush: csharp;\">public class Control : FrameworkElement\n{\n...\n    public static readonly DependencyProperty FontSizeProperty;\n...\n}</pre>\n<p>當然，並非這樣就結束了，這可是readonly耶，而且目前FontSizeProperty裡面也沒任何東西，所以我們必須要在靜態建構子中，給FontSizeProperty參照一個物件；我們使用DependencyProperty的靜態方法Register來參照一個物件，而裡面需要帶一些參數，第一個參數是和此DependencyProperty關聯的Property名稱，第二個是型別，第三個是誰註冊，其實還有第四個參數，這部分後面再講。</p>\n<pre class=\"brush: csharp;\">static Control()\n{\n    FontSizeProperty = DependencyProperty.Register(\"FontSize\", typeof(double), typeof(Control));\n}\n</pre>\n<p>到這邊，並沒有結束，雖然我們有這個欄位，但我們並沒有可以存取的方法，所以接下來我們要寫方法來存取；這裡的set和get大家應該都清楚了，但是SetValue和GetValue又是啥?其實在WPF裡面，UIElement是繼承DependencyObject這個物件而來，而DependencyObject又是繼承DispatcherObject(抽象)而來，而SetValue和GetValue就是從DispatcherObject而來的，所以我們可以直接呼叫使用。( 換言之，如果要實作Dependency Property，就必須繼承於DispatcherObject之下，不過這樣也很合理，畢竟，這是WPF的一個機制 )。</p>\n<pre class=\"brush: csharp;\">public string FontSize\n{\n    set { SetValue(FontSizeProperty, value ); }\n    get { return (double) GetValue(FontSizeProperty); }\n}</pre>\n<p>SetValue有兩個參數，第一個就是剛剛定的欄位( FontSizeProperty )，第二個就是要存進去的值，而GetValue，其實就是取出來，這樣就完成了Dependency Property程式碼撰寫。</p>\n<p>其實，WPF裡面幾乎都是使用Dependency Property機制來處理，最前面講到的TextBlock的FontSize，其實也是使用Dependency Property來處理的。</p>\n<h4>Dependency Property機制</h4>\n<p>說到這裡，我相信應該還有人有一堆問題，例如說，他們是怎樣傳遞的，以此圖來說，如果除了Window以外，都沒有給FontSize大小，後面的元件要怎樣知道Window所設定的FontSize?</p>\n<p><a href=\"http://lh4.ggpht.com/-EYuG9XcJ3H4/TujRj47MiVI/AAAAAAAABKY/bH31pnjb2D8/s1600-h/image%25255B17%25255D.png\"><img src=\"http://lh5.ggpht.com/-FtzVyAZelM0/TujRkt5KNcI/AAAAAAAABKc/h-k665EitEQ/image_thumb%25255B8%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>這邊，小弟我取用許薰尹老師文章的其中一個圖，如右邊所示，沒錯，WPF的屬性系統 ( 也就是Dependency Property機制 )會自動的延續 ( 繼承 ) 最上方的節點元件。</p>\n<p><a href=\"http://lh4.ggpht.com/-qjf_yv6UV4k/TujRlo9p3aI/AAAAAAAABKo/mLXYWTqTp3Q/s1600-h/image%25255B13%25255D.png\"><img src=\"http://lh5.ggpht.com/-8Se6B8VIdho/TujRmSK3-uI/AAAAAAAABKw/C_HOLTtICb0/image_thumb%25255B7%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>那這代表甚麼?其實WPF的Dependency Property會資訊存到某個Collection裡面，並自動進行處理，所以我們只要確定底下的節點，都有定義Dependency Property，那Dependency Property就會自動地去處理這些細節，我們完全可以不用管。</p>\n<h4>Dependency Property的設定!?</h4>\n<p>前面有談到，在Register時，還有第四個參數和第五個參數，其實第四個參數是用來設定一些Dependency Property的細節，例如是否要延續父層的屬性、是否會影響尺寸、預設值等等；而第五個參數是當值改變的時候，要呼叫的方法。</p>\n<pre class=\"brush: csharp;\">FrameworkPropertyMetadata metadata = new FrameworkPropertyMetadata();\nmetadata.AffectsMeasure = true;//是否會影響Element Size大小\nmetadata.Inherits = true;//是否延續上層\nFontSizeProperty = DependencyProperty.Register(\"FontSize\", typeof(double), \n    typeof(Control), metadata, ValidateFontSize);\n</pre>\n<p>然後這是值改變時，呼叫方法的寫法。</p>\n<pre class=\"brush: csharp;\">static void ValidateFontSize(DependencyObject obj,DependencyPropertyChangedEventArgs args)\n{...}\n</pre>\n<p>基本上，這就是整個Dependency Property的架構，利用Dependency Property，WPF就變得更簡單，也更容易去處理。</p>\n<p>下一篇，我們來談談附加屬性，也就是一開始接觸WPF，讓人匪夷所思的DockPanel.Dock(xxx,Dock.Right);這種寫法。</p>\n<h4>參考資料</h4>\n<p><a href=\"http://blogs.uuu.com.tw/Articles/post/2011/08/10/WPF%E7%9B%B8%E4%BE%9D%E5%B1%AC%E6%80%A7%E8%88%87%E9%99%84%E5%8A%A0%E5%B1%AC%E6%80%A7.aspx\">WPF相依屬性與附加屬性</a></p>","excerpt":"一直以來，我都認為Flex和WPF ( Silverlight ) 的架構、模式都差不多，反正就是利用XML進行視覺的排版，然後後面有邏輯程式進行處理，然後一堆類似的容器、Control、和事件傳遞模式。 沒錯，後來深深的發現，我錯了QQ，WPF的架構比Flex…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"TFS – Work Item、Area & Iterations","tags":["Scrum","TFS"]},"fields":{"slug":"/2011/11/30/TFS-–-Work-Item、Area-Iterations/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/TFS-–-Work-Item、Area-Iterations.md"},"previous":{"frontmatter":{"path":null,"title":"WPF - Attached Property 深入探討","tags":["Silveright","WPF"]},"fields":{"slug":"/2011/12/17/WPF-Attached-Property-深入探討/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/WPF-Attached-Property-深入探討.md"}}}}