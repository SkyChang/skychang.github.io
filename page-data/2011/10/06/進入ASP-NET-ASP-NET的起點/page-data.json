{"componentChunkName":"component---src-templates-page-js","path":"/2011/10/06/進入ASP-NET-ASP-NET的起點/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"進入ASP.NET - ASP.NET的起點","date":"06 October 2011","author":"Sky Chang","excerpt":null,"tags":["ASP.NET","ASP.NET MVC","IIS"],"coverImage":null},"id":"b0773129-4e23-5acd-af69-9aad580c1d80","html":"<p>最近開始深入ASP.NET的核心，花了很多時間來了解，也翻了很多書還有找了很多很多網站，同樣的如果不寫這篇，我想大概沒幾天我就忘記了，就像是委派一樣，看過四次，但還是只剩一些殘餘的印象XDD ( 所以下次一定要把委派整理起來- - )，所以我決定還是稱現在比較清楚的時候，趕快整理起來，並且寫到Blog來做個紀錄。</p>\n<h4>ASP.NET 核心</h4>\n<p>這系列是ASP.NET核心篇的起點，也就是ASP.NET底層是怎樣運作的，從一個HTTP Request近來的時候，會怎樣處理，Web應用程式又是怎樣吐回到Client的Browser，老實說，看完後，我覺得還滿有趣的 ( 但是看的時候一點也不有趣= = )，而這系列也是比較硬派一點的文章，我也試著用我了解的方式且比較多的例子來詮釋一遍，當然，如果有神人發現有誤，請務必和我說喔!</p>\n<h4>來寫一個Web Server吧!</h4>\n<p>當個使用者其實是最開心的，甚麼都可以不用管，出問題了還可罵說，怎麼寫得那麼爛…，但是身為程式開發人員就倒楣了，不但要被罵，還要找出哪裡有問題…，所以我們也必須去了解底層是怎樣運作，所以我們這邊簡單的從Browser開始講起；其實當一個Browser要求一個網頁的時候，其實是一堆文字的來來回回，也就是透過協定來進行Client和Server的傳輸 ( 細節就不說了，如果有機會，我在另外一篇補完 )； 而我們平常使用的IIS或是Apache等等Web Server，提供的網頁服務，就是再處理Browser的請求；當Browser需要一個東西，Web Server就吐回去一個東西，ok，我相信講到這邊，大家應該都沒有問題，那既然我們也知道協定、傳輸等等方式，是不是可以用C#等等語言寫一個Web Server!?，答案當然是可以，但我想應該沒有人會那麼無聊，寫出像IIS或是Apache那樣強大的Web Server…( 或是說，也很難寫出來，還是乖乖地用人家寫的吧 )，雖然無法寫出那麼強大的Web Server，但是簡單的還是可以吧!?，是的，就像下面的程式碼；不過不用急著去把它看完 ( 我想看到這麼長的程式，大概就會想直接按\"上一頁\"了吧… )；它的原理其實很簡單，利用TcpListener這個類別來監聽，聽到請求後就將資料吐回，當然你也可以用Socket這個類別或是HttpListener來實作；總之，我想強調的是，基本上Client和Server端通訊內容，其實也就是一堆文字，也就是利用這些文字來處理要做甚麼事情。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.IO;\nusing System.Threading;\nusing System.Web;\nusing System.Web.Hosting;\nusing System.Net;\n\nnamespace AspNetSimulator\n{\n    class WebHandle\n    {\n        private TcpListener _tcpListener;    //監聽用\n        private FileStream _fileStream;      //利用串流處理要求。\n        private string _virtualDir;\n        private string _realDir;\n\n        public WebHandle(string virtualDir, string realDir)\n        {\n            this._virtualDir = virtualDir;\n            this._realDir = realDir;\n        }\n\n        //啟動服務\n        public void StartService()\n        {\n            try\n            {\n                IPEndPoint address = new IPEndPoint(IPAddress.Loopback, 8080);\n                _tcpListener = new TcpListener(address);\n                //啟動監聽\n                _tcpListener.Start();   \n                Console.WriteLine(\"啟動服務...\");\n\n                WebServiceStart();\n            }\n            catch (NullReferenceException)\n            {\n                Console.WriteLine(\"NullReferenceException throwed!\");\n            }\n        }\n\n        //主要服務\n        public void WebServiceStart()\n        {\n            while (true)\n            {\n                //建立連線\n                TcpClient tcpClient = _tcpListener.AcceptTcpClient();\n                Console.WriteLine(\"連線建立...\");\n                //取得網路串流\n                NetworkStream networkStream = tcpClient.GetStream();\n                //設定使用UTF-8\n                Encoding utf8 = Encoding.UTF8;\n                byte[] request = new byte[4096];\n                //讀取請求，並塞到request裡面，此方法會傳回長度。\n                int length = networkStream.Read(request, 0, 4096);\n                //轉換成人類能看得懂的字串。\n                string requestString = utf8.GetString(request, 0, length);\n\n                string output = \"\";\n                //中間略，簡單的說就是將網頁輸出到output...\n\n                //以下只是簡單的將訊息送出。\n                string statusLine = \"HTTP/1.1 200 OK\\r\\n\";\n                byte[] outputStatusLineBs = utf8.GetBytes(statusLine);\n                byte[] outputBodyBs = utf8.GetBytes(output);\n                string responseHeader = string.Format(\"Content-Type: text/html;charset=UTF-8\\r\\nContent-Length:{0}\\r\\n\",outputBodyBs.Length);\n                byte[] outputResponseHeaderBs = utf8.GetBytes(responseHeader);\n                networkStream.Write(outputStatusLineBs, 0, outputStatusLineBs.Length);\n                networkStream.Write(outputResponseHeaderBs, 0, outputResponseHeaderBs.Length);\n                networkStream.Write(new byte[]{13,10},0,2);\n                networkStream.Write(outputBodyBs, 0, outputBodyBs.Length);\n                tcpClient.Close();\n            }\n        }\n    }\n}\n</pre>\n<h4>.NET的Application Domain</h4>\n<p>在談論ASP.NET之前，先說一個觀念，那就是Application Domain，他是.NET裡面管理的最小單位，舉例來說，每個Web應用程式會有一個Application Domain ( 和 Application Pool不同…)，而Web Server也會有一個Application Domain；而Application Domain會有一些特性，例如說，兩個Application Domain不能直接互通、執行時，以Application Domian為邊界、卸載的時候也以Application Domain為單位 ( 但是可以隨時動態載入組件 )等等。</p>\n<h4>為何會提到Application Domain?</h4>\n<p>其實是因為Application Domain有一個關鍵性的特點，發現了嗎?就是兩個Application Domain不能直接互通!，簡單的說，當一個Web Server收到Client的請求時，Web Server沒辦法跨Application Domain到Web應用程式的Application Domain來讓Web應用程式處理這個請求 ( 也就是說Web應用程式沒辦法得知這個Client的請求，所以也沒辦法處理，然後吐回處理過的html網頁… )。</p>\n<h4>MarshalByRefObject是救星!</h4>\n<p>沒錯，解決辦法就是使用MarshalByRefObject這個類別，繼承了這個類別的物件，可以讓Web Server透過他來將資料封裝起來並傳遞到Web應用程式裡面去，然後再吐回Web Server。</p>\n<h4>來看看MarshalByRefObject如何寫</h4>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Web.Hosting;\nusing System.Web;\n\nnamespace AspNetSimulator\n{\n    //繼承MarshalByRefObject來讓MyAspNetHost跨越兩個Application Domain \n    class MyAspNetHost:MarshalByRefObject\n    {\n         public void  ProcessRequest( string fileName ,ref string output)\n         {\n             //利用記憶體當串流。\n             MemoryStream memoryStream=new MemoryStream();\n             //設定輸出，來將網頁透過這個Stream送到這裡。\n             StreamWriter streamWriter = new StreamWriter(memoryStream);\n             //自動更新 \n             streamWriter.AutoFlush = true;      \n             //利用HttpWorkRequest類別，來設定要給Web應用程式的請求。\n             //第一個參數是檔案名稱，第二個參數是query，第三個參數是將產生出來的html要透過哪個Stream做寫入至Memory\n             HttpWorkerRequest worker = new SimpleWorkerRequest(fileName, \"\", streamWriter);   \n             //正式派發出去執行。\n             HttpRuntime.ProcessRequest(worker) ;\n             //準備讀取的Stream\n             StreamReader streamReader = new StreamReader(memoryStream);\n             //移動指標\n             memoryStream.Position = 0;\n             //從頭讀到尾，並且塞到output裡面去。\n             output = streamReader.ReadToEnd();\n         }\n    }\n}\n</pre>\n<p>這裡要特別注意，此物件並不是用來傳遞，而是定義了這個物件以後，到時候我們的Web Server就可以來呼叫這個物件的方法，如上所示，我們就可以在Web Server這個類別使用ProcessRequest()這個方法；接下來，我們稍微解釋一下程式碼，基本上前面幾行設定串流模式，並利用記憶體當儲存體；比較需要注意的是這兩行。</p>\n<pre class=\"brush: csharp;\"> //利用HttpWorkRequest類別，來設定要給Web應用程式的請求。\n //第一個參數是檔案名稱，第二個參數是query，第三個參數是將產生出來的html要透過哪個Stream做寫入至Memory\n HttpWorkerRequest worker = new SimpleWorkerRequest(fileName, \"\", streamWriter);   \n //正式派發出去執行。\n HttpRuntime.ProcessRequest(worker) ;\n</pre>\n<p>我們利用SimpleWorkerRequest類別來產生HttpWorkerRequest這個抽象類別的實體 ( 也就是woker )，這裡有三個參數，第一個參數其實就是檔案名稱，例如Test.aspx，而第二個參數則是query，已就是檔案後面的?xxx=xxxx這種URL的query，第三個則表示未來Web應用程式產出的HTML要利用哪個串流來進行寫入，( 而這邊因為是範例，第二個參數就直接給空白)，最後再將這個實體( worker ) 送到HttpRuntime.ProcessRequest來執行，送進去後，就是Web應用程式的事情了，經過一連串的執行運算，最後會產生HTML，並且透過串流寫到記憶體，所以就可以用以下程式碼進行取出。</p>\n<pre class=\"brush: csharp;\"> //準備讀取的Stream\n StreamReader streamReader = new StreamReader(memoryStream);\n //移動指標\n memoryStream.Position = 0;\n //從頭讀到尾，並且塞到output裡面去。\n output = streamReader.ReadToEnd();\n</pre>\n<p>要注意的是output是利用ref的方式，也就是說，到時候Web Server會定義一個output的變數，未來這裡會直接寫回到Web Server的output變數裡面，這樣，就完成了中介的MarshalByRefObject物件。</p>\n<h4>ApplicationHost.CreateApplicationHost方法</h4>\n<p>開始撰寫Web Server之前，還有一個東西需要講，那就是ApplicationHost.CreateApplicationHost這個方法，CreateApplicationHost是ApplicationHost的一個靜態方法，他可以幫助我們建立Web應用程式的Application Domain；我們執行程式時，當然會先將Web Server執行起來，也會建立起Web Server的Application Domain，但是Web應用程式呢?，所以我們會在Web Server裡面去建立Web應用程式的Application Domain，而建立的方法就是使用CreateApplicationHost。</p>\n<pre class=\"brush: csharp;\">//利用CreateApplicationHost方法來建立一個ASP.NET的Application Domain，\n//以便執行ASP.NET。\n_myAspNetHost = (MyAspNetHost)ApplicationHost.CreateApplicationHost\n    (typeof(MyAspNetHost), _virtualDir, _realDir);\n</pre>\n<p>如上程式碼，就是建立Web應用程式的Application Domain的寫法，他會帶三個參數，第一個是最難解釋的，先跳過，第二個參數其實就是Web應用程式的根所對應的虛擬路徑，第三個則是實體路徑；接下來我們回來講第一個參數，通常我們會把剛剛寫好的MarshalByRefObject物件放到第一個參數，並且使用typeof來取得MarshalByRefObject的Type這個型別，老實說，這塊我看了很久，最後還去翻Source來查，才知道比較細的細節，以下我們先看一下CreateApplicationHost這個程式碼。</p>\n<pre class=\"brush: csharp;\">[SecurityPermission(SecurityAction.Demand, Unrestricted=true)]\npublic static object CreateApplicationHost(Type hostType, string virtualDir, string physicalDir)\n{\n    if (Environment.OSVersion.Platform != PlatformID.Win32NT)\n    {\n        throw new PlatformNotSupportedException(SR.GetString(\"RequiresNT\"));\n    }\n    if (!StringUtil.StringEndsWith(physicalDir, Path.DirectorySeparatorChar))\n    {\n        physicalDir = physicalDir + Path.DirectorySeparatorChar;\n    }\n    ApplicationManager applicationManager = ApplicationManager.GetApplicationManager();\n    string appId = (virtualDir + physicalDir).GetHashCode().ToString(\"x\");\n    return applicationManager.CreateInstanceInNewWorkerAppDomain(hostType, appId, VirtualPath.CreateNonRelative(virtualDir), physicalDir).Unwrap();\n}\n</pre>\n<p>上面在敘說CreateApplicationHost這個方法，我們其實可以看到，傳進來的Type型別，又傳入到CreateInstanceInNewWorkerAppDomain裡面去，所以再往下看吧。</p>\n<pre class=\"brush: csharp;\">internal ObjectHandle CreateInstanceInNewWorkerAppDomain(Type type, string appId, VirtualPath virtualPath, string physicalPath)\n{\n    IApplicationHost appHost = new SimpleApplicationHost(virtualPath, physicalPath);\n    HostingEnvironmentParameters hostingParameters = new HostingEnvironmentParameters {\n        HostingFlags = HostingEnvironmentFlags.HideFromAppManager\n    };\n    return this.CreateAppDomainWithHostingEnvironmentAndReportErrors(appId, appHost, hostingParameters).CreateInstance(type.AssemblyQualifiedName);\n}\n</pre>\n<p>到這邊，直接跳到最後一行，我們可以看到type.AssmblyQualifiedName，其實這是取出type的詳細資訊，也就是MarshalByRefObject的NameSpace、版本、等等的詳細資訊；這邊如果再繼續查下去，還有非常多層，我就跳過不講了，但至少我們發現了關鍵，也就是說，這邊轉成Type是為了讓Web應用程式的Application Domain在runtime時，動態載入MarshalByRefObject這個物件，所以在runtime的時候，程式會去尋找GAC和網站底下的bin目錄，並將之載入，所以需要知道MarshalByRefObject這個物件的詳細資訊，所以使用Type來取得詳細資訊；到這邊，我們知道了CreateApplicatinHost如何使用，我們就可以開始寫Web Server了。</p>\n<h4>撰寫Web Server</h4>\n<p>接下來就是整段的Web Server程式碼，下面比較簡單的都註解了，基本上看一下應該都可以看得懂。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.IO;\nusing System.Threading;\nusing System.Web;\nusing System.Web.Hosting;\nusing System.Net;\n\nnamespace AspNetSimulator\n{\n    class WebHandle\n    {\n        //繼承了MarshalByRefObject的MyAspNetHost，\n        //負責處理We Server 和 Asp.net Application Domain之間的通訊\n        private MyAspNetHost _myAspNetHost;\n        private TcpListener _tcpListener;    //監聽用\n        private FileStream _fileStream;      //利用串流處理要求。\n        private string _virtualDir;\n        private string _realDir;\n\n        public WebHandle(string virtualDir, string realDir)\n        {\n            this._virtualDir = virtualDir;\n            this._realDir = realDir;\n        }\n\n        //啟動服務\n        public void StartService()\n        {\n            try\n            {\n                IPEndPoint address = new IPEndPoint(IPAddress.Loopback, 8080);\n                _tcpListener = new TcpListener(address);\n                //啟動監聽\n                _tcpListener.Start();   \n                Console.WriteLine(\"啟動服務...\");\n                //利用CreateApplicationHost方法來建立一個ASP.NET的Application Domain，\n                //以便執行ASP.NET。\n                _myAspNetHost = (MyAspNetHost)ApplicationHost.CreateApplicationHost\n                    (typeof(MyAspNetHost), _virtualDir, _realDir);\n              //啟動服務\n                WebServiceStart();\n            }\n            catch (NullReferenceException)\n            {\n                Console.WriteLine(\"NullReferenceException throwed!\");\n            }\n        }\n\n        //主要服務\n        public void WebServiceStart()\n        {\n            while (true)\n            {\n                //建立連線\n                TcpClient tcpClient = _tcpListener.AcceptTcpClient();\n                Console.WriteLine(\"連線建立...\");\n                //取得網路串流\n                NetworkStream networkStream = tcpClient.GetStream();\n                //設定使用UTF-8\n                Encoding utf8 = Encoding.UTF8;\n                byte[] request = new byte[4096];\n                //讀取請求，並塞到request裡面，此方法會傳回長度。\n                int length = networkStream.Read(request, 0, 4096);\n                //轉換成人類能看得懂的字串。\n                string requestString = utf8.GetString(request, 0, length);\n\n                string output = \"\";\n                //這裡是關鍵，\n                //簡單的說，就是WebHandle這個Application Domain 透過 _myAspNetHost 來和\n                //ASP.NET Application Domain傳遞訊息。\n                //( 這裡因為是Demo，所以就直接指定為Test.aspx網頁了 )\n                //而使用ref來將ASP.NET Application Domain的資料塞回這裡。\n                _myAspNetHost.ProcessRequest(\"Test.aspx\", ref output);\n                //以下只是簡單的將訊息送出。\n                string statusLine = \"HTTP/1.1 200 OK\\r\\n\";\n                byte[] outputStatusLineBs = utf8.GetBytes(statusLine);\n                byte[] outputBodyBs = utf8.GetBytes(output);\n                string responseHeader = string.Format(\"Content-Type: text/html;charset=UTF-8\\r\\nContent-Length:{0}\\r\\n\",outputBodyBs.Length);\n                byte[] outputResponseHeaderBs = utf8.GetBytes(responseHeader);\n                networkStream.Write(outputStatusLineBs, 0, outputStatusLineBs.Length);\n                networkStream.Write(outputResponseHeaderBs, 0, outputResponseHeaderBs.Length);\n                networkStream.Write(new byte[]{13,10},0,2);\n                networkStream.Write(outputBodyBs, 0, outputBodyBs.Length);\n                tcpClient.Close();\n            }\n        }\n    }\n}\n</pre>\n<p>我們會在_tcpListerer.start()後，建立Web應用程式的Application Domain，來讓Web應用程式準備運作，然後進入WebServiceStart方法，利用無窮迴圈來讓服務不中斷，而當程式讀到這行時，就會暫停，直到有請求進來，並繼續執行下去；另外WebServiceStart可以使用執行序來進行多執行序的處理，這裡是簡單的Demo，就直接這樣寫了。</p>\n<pre class=\"brush: csharp;\">TcpClient tcpClient = _tcpListener.AcceptTcpClient();\n</pre>\n<p>然後就進行串流的讀取，將請求的部分進行處理，如果寫的複雜一點，可能也還需去判斷要求的是哪個檔案，或是有沒有query等等的處理。( 所以沒事不要自己寫Web Server… )最後到下面這行，這邊就是透過繼承了MarshalByRefObject的物件，並呼叫此物件的方法，如上所說，經過一連串的執行，就會把html資料吐回到output裡面。</p>\n<pre class=\"brush: csharp;\">//這裡是關鍵，\n//簡單的說，就是WebHandle這個Application Domain 透過 _myAspNetHost 來和\n//ASP.NET Application Domain傳遞訊息。\n//( 這裡因為是Demo，所以就直接指定為Test.aspx網頁了 )\n//而使用ref來將ASP.NET Application Domain的資料塞回這裡。\n_myAspNetHost.ProcessRequest(\"Test.aspx\", ref output);\n</pre>\n<p>最後，我們去把這些資料輸出回瀏覽器，就完成了這個平常簡單的一次請求…</p>\n<h4>還有一小段進入點!</h4>\n<p>另外，有沒有發現上面全部都是類別，完全沒有進入點，其實我是使用了Console專案來撰寫，所以下面補上程式的進入點，於是Web Server (偽) 就完成了=w=。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AspNetSimulator\n{\n    class ServerSimulator\n    {\n        static void Main(string[] args)\n        {\n            WebHandle webHandle = new WebHandle(\"/\", \"C:\\\\My\\\\TestWeb\");\n            webHandle.StartService();\n        }\n    }\n}\n</pre>\n<p>寫了那麼多，其實也只是ASP.NET的開頭，也希望能讓大家對ASP.NET的一些基礎能更加瞭解!</p>","excerpt":"最近開始深入ASP.NET的核心，花了很多時間來了解，也翻了很多書還有找了很多很多網站，同樣的如果不寫這篇，我想大概沒幾天我就忘記了，就像是委派一樣，看過四次，但還是只剩一些殘餘的印象XDD…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"開發人應該學的，用Visual Studio開發SQL(SQL Server Data Tools) - 不使用DataBase Project的開發模式","tags":["SQL Server","Tools","Visual Studio"]},"fields":{"slug":"/2011/10/04/開發人應該學的，用Visual-Studio開發SQL-SQL-Server-Data-Tools-不使用DataBase-Project的開發模式/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/開發人應該學的，用Visual-Studio開發SQL-SQL-Server-Data-Tools-不使用DataBase-Project的開發模式.md"},"previous":{"frontmatter":{"path":null,"title":"ASP.NET MVC - WebGrid配合Ajax動態刪除WebGrid的Row","tags":["ASP.NET MVC","JavaScript"]},"fields":{"slug":"/2011/10/11/ASP-NET-MVC-WebGrid配合Ajax動態刪除WebGrid的Row/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/ASP-NET-MVC-WebGrid配合Ajax動態刪除WebGrid的Row.md"}}}}