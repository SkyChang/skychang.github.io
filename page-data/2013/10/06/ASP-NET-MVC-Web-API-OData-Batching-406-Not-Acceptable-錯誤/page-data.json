{"componentChunkName":"component---src-templates-page-js","path":"/2013/10/06/ASP-NET-MVC-Web-API-OData-Batching-406-Not-Acceptable-錯誤/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"ASP.NET MVC - Web API OData Batching 406 Not Acceptable 錯誤","date":"06 October 2013","author":"Sky Chang","excerpt":null,"tags":["ASP.NET MVC","JavaScript","JayData","OData","WCF"],"coverImage":null},"id":"abe60767-ab84-5b69-8adf-ab84dcf86e1a","html":"<p>這篇稍微簡單的紀錄一下，浪費掉我<strike>打電動</strike>認真陪家人的兩個放假天，那話也說在前面，根據查到的狀況，看起來，應該是Web API的BUG，但官方並沒有承諾甚麼時候會改好，只能誠心祈禱RTM的Web API 2能順利修正，所以，未來如果有遇到類似的問題，大家可以試著升級成最新版本看看。</p>\n<p>最後，和這件事以外的另外一個補充，先不論這件事情，目前Web API OData的支援程度還是有很多地方沒完整實現，所以很容易踩到地雷，當然，官方還是在努力地將Web API越做越好；而如果害怕擔心，對於WCF又已經熟到不行的朋友，那可以考慮直接用WCF時做OData Endpoint吧=v=。</p>\n<p>那這個問題是甚麼??..</p>\n<p>主要是小弟在整合OData方案的時候，搭配JayData和Datajs來協助對OData Service來進行資料的管控與存取，一般的使用上，都沒遇到甚麼多大的問題 ( 也吃了不少苦….因為現在文件幾乎都是針對WCF… )，但最近在處理以下Code的時候，缺發生了一個比較棘手的問題；喔，對了，看不太懂此Code沒關係，簡單的說，我就是要利用JS來新增資料，先用add去新增到Context，然後再用JayData的Framework來saveChanges方法，一次更新。</p>\n<pre class=\"brush: js;\">var CustomerAgreementType =\n    new InternalIMS.Model.CustomerAgreementType({ CustomerID: fkID });\nCustomerAgreementType.ModifyDate = Date.now();\n\nmydatabase.Agreement.add(model);\nmydatabase.CustomerAgreementType.add(CustomerAgreementType);\n\nmydatabase.saveChanges(function () {\n\n});\n</pre>\n<p>上面那個Code看不懂其實沒關係，總之，我想要的效果，就是利用一次的Request，來送出兩個新增的訊息( 以前的話，要送出兩次Request來達成新增。)</p>\n<p>而之前的Web API連此功能都沒有…Orz..在Web API 2也已經提供了此功能，此功能就稱為Batching，有興趣的朋友，可以看<a href=\"http://aspnetwebstack.codeplex.com/wikipage?title=Web%20API%20Request%20Batching&#x26;referringTitle=Specs\" title=\"Web%20API%20Request%20Batching&#x26;referringTitle=Specs\">這篇架設</a>。(其實也只是多設定一行而已…)</p>\n<p>但真正的問題在後面，我們先來看一下，要新增兩筆資料的Requst，如下圖，我們可以看到一次發送兩筆POST ( 因為我們要新增嘛… )</p>\n<p><a href=\"http://lh4.ggpht.com/-Ri8BqMbJ0e4/UlEkgDC69qI/AAAAAAAAIEo/GVB2YZOtLpQ/s1600-h/image%25255B3%25255D.png\"><img src=\"http://lh5.ggpht.com/-xwRlr6dRe6w/UlEkhUH2SqI/AAAAAAAAIEw/n_MpXTjzmZc/image_thumb%25255B1%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>但當我們看Response的時候，我們可以看到發生了406 Not Acceptable錯誤。</p>\n<p><a href=\"http://lh6.ggpht.com/-nt2LcC-bXyw/UlEkiJJQDxI/AAAAAAAAIE4/wMxRI705seA/s1600-h/image%25255B7%25255D.png\"><img src=\"http://lh3.ggpht.com/-aIudSDg1QuI/UlEkjMc5GbI/AAAAAAAAIFA/i6ypR4neif8/image_thumb%25255B3%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>當下發生這個錯誤，真的是把我搞死…後來才查到，原來是OData服務網址的錯誤，也就是這張圖的這個地方。</p>\n<p><a href=\"http://lh5.ggpht.com/-CwiuMHnbZQo/UlEkkv49sNI/AAAAAAAAIFI/n0Bl24yZspo/s1600-h/image%25255B11%25255D.png\"><img src=\"http://lh6.ggpht.com/-hrMO-2y96_M/UlEkl5ThvqI/AAAAAAAAIFQ/kB7Fq6g-Qmo/image_thumb%25255B5%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>是的，其實是URL錯誤，上圖的URL的位置其實是<a href=\"http://localhost/Agreement%E5%92%8Chttp://localhost/CustomerAgreementType%EF%BC%8C%E4%BD%86%E5%AF%A6%E9%9A%9B%E4%B8%8A%EF%BC%8C%E6%88%91%E5%80%91%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8D%BB%E6%87%89%E8%A9%B2%E6%98%AF%E5%9C%A8localhost/OData/Agreement%E4%B9%8B%E4%B8%8B%E2%80%A6%E6%89%80%E4%BB%A5%E6%9C%83%E8%BF%94%E5%9B%9E406%E9%8C%AF%E8%AA%A4%E3%80%82\">http://localhost/Agreement和http://localhost/CustomerAgreementType，但實際上，我們的位置卻應該是在localhost/OData/Agreement之下…所以會返回406錯誤。</a></p>\n<p>為了驗證真的是這個問題，所以小弟我直接用datajs來進行測試，Code如下。</p>\n<pre class=\"brush: js;\">OData.request({\n    requestUri: \"/OData/$batch\",\n    method: \"POST\",\n    data: {\n        __batchRequests: [\n            {\n                __changeRequests: [\n                  { requestUri: \"/OData/Agreement\", method: \"POST\", data: model }\n                ]\n            },\n            { requestUri: \"/OData/Agreement\", method: \"GET\" }\n        ]\n    }\n}, function (data, response) {\n    alert(\"ok\");\n}, function () {\n    alert(\"request failed\");\n}, OData.batchHandler);\n</pre>\n<p>結果就很順利…我們可以看到POST後的網址已經正確了。</p>\n<p><a href=\"http://lh4.ggpht.com/-O2DJIhYyZJ8/UlEkmg84sII/AAAAAAAAIFY/rTHGbTGkhFc/s1600-h/image%25255B15%25255D.png\"><img src=\"http://lh5.ggpht.com/-nI4SidT9gRY/UlEknozNmQI/AAAAAAAAIFg/IMIzVjAZbeQ/image_thumb%25255B7%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>而Respose也正常了。</p>\n<p><a href=\"http://lh6.ggpht.com/-td-3b7nkx2Q/UlEko4JVz6I/AAAAAAAAIFo/PYNf_lJvQjQ/s1600-h/image%25255B20%25255D.png\"><img src=\"http://lh6.ggpht.com/-8Sf3w3wA7Ao/UlEkp_3Z3KI/AAAAAAAAIFw/bwn1sqA23VQ/image_thumb%25255B10%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>所以到這邊，就可以推測是這裡的問題了。</p>\n<p>至於解法，目前小弟我查到的訊息，除了等Web API更新以外，要不就是自己重新定義處理器。</p>\n<p>處理器的Code如下。( 此Code來源於<a href=\"http://jaydata.org/forum/viewtopic.php?f=3&#x26;t=300\">JayData論壇</a>的Fenderbender神人 )</p>\n<pre class=\"brush: csharp;\">public class PathFixODataBatchHandler : DefaultODataBatchHandler\n        {\n\n            public PathFixODataBatchHandler(HttpServer httpServer)\n                : base(httpServer)\n            {\n            }\n\n            public override async Task&lt;IList&lt;ODataBatchResponseItem&gt;&gt; ExecuteRequestMessagesAsync(IEnumerable&lt;ODataBatchRequestItem&gt; requests, CancellationToken cancellationToken)\n            {\n                if (requests == null)\n                {\n                    throw new System.ArgumentNullException(\"requests\"); // Error.ArgumentNull(\"requests\");\n                }\n\n                IList&lt;ODataBatchResponseItem&gt; responses = new List&lt;ODataBatchResponseItem&gt;();\n\n                try\n                {\n                    foreach (ODataBatchRequestItem request in requests)\n                    {\n                        fixRequestUri(request);\n                        responses.Add(await request.SendRequestAsync(Invoker, cancellationToken));\n                    }\n                }\n                catch\n                {\n                    foreach (ODataBatchResponseItem response in responses)\n                    {\n                        if (response != null)\n                        {\n                            response.Dispose();\n                        }\n                    }\n                    throw;\n                }\n\n                return responses;\n            }\n\n            private void fixRequestUri(ODataBatchRequestItem request)\n            {\n                foreach (HttpRequestMessage req in ((ChangeSetRequestItem)request).Requests)\n                {\n                    var oldUri = req.RequestUri;\n                    var newUriBuilder = new UriBuilder(oldUri);\n                    newUriBuilder.Path = \"/odata\" + newUriBuilder.Path;\n                    req.RequestUri = newUriBuilder.Uri;\n                }\n            }\n        }\n</pre>\n<p>其實重點就是後面，將path加上\"/odata\"。</p>\n<p>然後我們在Web API的Router Config再來調整一下，改用上面的Class。</p>\n<pre class=\"brush: csharp;\">config.Routes.MapODataRoute(\n    routeName: \"ODataRoute\",\n    routePrefix: \"odata\",\n    model: GetModel(),\n    //batchHandler: new DefaultODataBatchHandler(GlobalConfiguration.DefaultServer));\n    batchHandler: new PathFixODataBatchHandler(GlobalConfiguration.DefaultServer));\nconfig.EnableQuerySupport();\n</pre>\n<p>這樣就可以了~~</p>\n<h4>後記</h4>\n<p>目前查出來的文章，都指向ASP.NET WEB API的問題XDD，因為除了JayData外，BreezeJS也有同樣的問題；但WCF下，就無此問題；但不管怎樣，有用到此技術的朋友們，可以稍微注意一下喔!!</p>\n<h4>參考網址</h4>\n<ul>\n<li><a href=\"http://www.odata.org/documentation/odata-v2-documentation/batch-processing/\">http://www.odata.org/documentation/odata-v2-documentation/batch-processing/</a></li>\n<li><a href=\"http://stackoverflow.com/questions/18813890/post-batch-request-with-breezejs\">http://stackoverflow.com/questions/18813890/post-batch-request-with-breezejs</a></li>\n<li><a href=\"http://jaydata.org/forum/viewtopic.php?f=3&#x26;t=300\">http://jaydata.org/forum/viewtopic.php?f=3&#x26;t=300</a></li>\n<li><a href=\"https://github.com/jaydata/jaydata/issues/131\">https://github.com/jaydata/jaydata/issues/131</a></li>\n<li><a href=\"http://aspnetwebstack.codeplex.com/wikipage?title=Web%20API%20Request%20Batching&#x26;referringTitle=Specs\" title=\"Web%20API%20Request%20Batching&#x26;referringTitle=Specs\">http://aspnetwebstack.codeplex.com/wikipage?title=Web%20API%20Request%20Batching&#x26;referringTitle=Specs</a></li>\n</ul>","excerpt":"這篇稍微簡單的紀錄一下，浪費掉我打電動認真陪家人的兩個放假天，那話也說在前面，根據查到的狀況，看起來，應該是Web API的BUG，但官方並沒有承諾甚麼時候會改好，只能誠心祈禱RTM的Web API…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"Windows Azure - 在Azure上建立SQL Server AlwaysOn需要的容錯移轉叢集","tags":["Azure","SQL Server","Windows Server"]},"fields":{"slug":"/2013/09/21/Windows-Azure-在Azure上建立SQL-Server-AlwaysOn需要的容錯移轉叢集/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/Windows-Azure-在Azure上建立SQL-Server-AlwaysOn需要的容錯移轉叢集.md"},"previous":{"frontmatter":{"path":null,"title":"Microsoft TechDays 2013","tags":["Azure","Hyper-V","Sky的IT碎碎念","SQL Server","Windows","Windows Server"]},"fields":{"slug":"/2013/10/06/Microsoft-TechDays-2013/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/Microsoft-TechDays-2013.md"}}}}