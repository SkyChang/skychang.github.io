{"componentChunkName":"component---src-templates-page-js","path":"/2012/04/04/Entity-Framework-使用Code-First的Enabling-Migrations/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Entity Framework - 使用Code First的Enabling Migrations","date":"04 April 2012","author":"Sky Chang","excerpt":null,"tags":["Entity Framework","Visual Studio"],"coverImage":null},"id":"8b43413f-9828-53b2-aa50-570a46d9b349","html":"<p><a href=\"http://blog.sanc.idv.tw/2013/05/entity-framework-code-first-ver-50.html\">上一篇</a>提到Code First，也提到了一個問題，這個問題就是，如果我們在第一次使用Code First並建立好資料庫，但如果第二次需要增加個資料欄位，該怎麼辦?如果是以前，只能很無奈地把db刪除掉，然後在執行一次，但自從Entity Framework 4.3版本後，多了一個新功能，那就叫做Enabling Migrations ( 啟動遷移 )，這個功能的目的，就是可以讓不用刪除db的情況下，加入新的欄位喔!</p>\n<p>在開始前，我要先證明一下，如果沒有使用Enabling Migrations的情況下，會發生甚麼事情，我們假設已經利用Code First建立了一個Table ClientBasic；而現在要在ClientBasic多加上一個EName，所以如果是理想的狀況下，因該會在db裡面多加上EName的欄位!(這裡的ClientBasicId上面有個Key，表示要使用這個屬性為PK)</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MigrationsCodeDemo\n{\n    public class ClientBasic\n    {\n        [Key]\n        public int ClientBasicId { get; set; }\n        public string Name { get; set; }\n        public string EName { get; set; }\n    }\n}\n</pre>\n<p>但現實總是殘酷的，如果這樣做，就會拋出InvalidOperationException的例外。</p>\n<blockquote>\n<p><em>”The model backing the 'XXXContext' context has changed since the database was created. Consider using Code First Migrations to update the database (</em><a href=\"http://go.microsoft.com/fwlink/?LinkId=238269\"><em>http://go.microsoft.com/fwlink/?LinkId=238269</em></a>_).” _</p>\n</blockquote>\n<p><a href=\"http://lh3.ggpht.com/-diS46e-axuE/T3smkNsHZPI/AAAAAAAAB-I/vBg0j5GOyR0/s1600-h/image%25255B3%25255D.png\"><img src=\"http://lh3.ggpht.com/-d8GtYIj8f50/T3smlV8a7LI/AAAAAAAAB-Q/cgvTnGSl6XU/image_thumb%25255B1%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>不過也因為會發生這樣的問題，才會有4.3版本的EF，而且也才會有這篇文章!這時候要怎樣做呢，首先，要先啟動\"Enable-Migrations\"，正常情況下，應該是不會開啟Package Manager Console視窗，所以我們可以先透過下圖的位置開啟此視窗。</p>\n<p><a href=\"http://lh6.ggpht.com/-FXVLghqwUiM/T3smmXJRJsI/AAAAAAAAB-Y/jNwVfhXC5Hc/s1600-h/image%25255B7%25255D.png\"><img src=\"http://lh5.ggpht.com/-BCaVwkpspvE/T3smoHTViII/AAAAAAAAB-g/bfKWAY__iv8/image_thumb%25255B3%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>接下來，在Package Manager Console視窗下的PM後面打上Enable-Migrations，如果懶得全部打完，也可以打Ena然後按下Tab，會跳出來給你選。( 向小弟一樣的懶人專用!! )</p>\n<p><a href=\"http://lh5.ggpht.com/-p_SOaWqcXSU/T3smpI3hf5I/AAAAAAAAB-o/AAEGNDlCdS8/s1600-h/image%25255B15%25255D.png\"><img src=\"http://lh5.ggpht.com/-JYi7t7q1MtM/T3smqWcsABI/AAAAAAAAB-w/h96Po-gCKy8/image_thumb%25255B7%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>如果出現紅字。</p>\n<blockquote>\n<p>Detected database created with a database initializer. Scaffolded migration '201204031530186_InitialCreate' corresponding to current database schema. To use an automatic migration instead, delete the Migrations folder and re-run Enable-Migrations specifying the -EnableAutomaticMigrations parameter.</p>\n</blockquote>\n<p>那表示，目前已經有Migrations目錄，而如果要啟動自動遷移，必須把剛剛建立好的Migrations目錄給砍掉，並且下Enable-Migrations –EnableAutomaticMigrations，但我們這篇是講手動的部分，所以也不需要啟動自動Migrations，所以不用管這串紅字，自動的部分後面會再提到。</p>\n<p>當執行完命令後，就會產生一個Migrations文件夾，這個新的文件夾中包含兩個文件。</p>\n<p>Configuration Class。這個Class的作用在於，允許你設定要遷移那些Context。這個範例中，我們會使用預設的配置，因為這個範例只有一個ClientBasicContext，所以預設產生的Configuration Class就已經夠用了。</p>\n<p>另外一個檔案室InitalCreate，這個檔案會被建立出來，是因為我們在啟動Enabling Migrations之前，就已經先建立資料庫了，所以這個檔案會被建立出來；這個檔案的用處是，他會將目前所建立好的資料庫欄位給記錄下來，在這邊而言，就是紀錄了ClientBasicId和Name。</p>\n<p>我來看一下圖，會建立這些東西。</p>\n<p><a href=\"http://lh6.ggpht.com/-nC_q_jwi0IE/T3smro0kw7I/AAAAAAAAB-4/FECIxIQR07M/s1600-h/image%25255B18%25255D.png\"><img src=\"http://lh4.ggpht.com/--hlNgJH9BgY/T3smsnn6k-I/AAAAAAAAB_A/o4EQwIktGI4/image_thumb%25255B8%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>建立好出最基礎的樣板後，我們要開始進行增加EName的動作了，我們先回顧一下程式碼，我們這次碰到的問題，就是新增加了EName，但產生錯誤。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace MigrationsCodeDemo\n{\n    public class ClientBasic\n    {\n        [Key]\n        public int ClientBasicId { get; set; }\n        public string Name { get; set; }\n        public string EName { get; set; }\n    }\n}\n</pre>\n<p>我們這邊要在Package Manager Console多下一個指令，稱為Add-Migration，如下圖，我們在PM前面打上Add-Migration AddEName。</p>\n<p><a href=\"http://lh3.ggpht.com/-iyCHs0S-Mv0/T3smt0actdI/AAAAAAAAB_I/rfRUurQUsb0/s1600-h/image%25255B22%25255D.png\"><img src=\"http://lh5.ggpht.com/-_OjrSR2F9NA/T3snHyli8EI/AAAAAAAAB_Q/oLnCzvh2zaQ/image_thumb%25255B10%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>然後，這次又出現長長的一串英文。</p>\n<blockquote>\n<p>The Designer Code for this migration file includes a snapshot of your current Code First model. This snapshot is used to calculate the changes to your model when you scaffold the next migration. If you make additional changes to your model that you want to include in this migration, then you can re-scaffold it by running 'Add-Migration 201204031603044_AddEName' again.</p>\n</blockquote>\n<p>簡單地說，就是這個AddEName的檔案內含了目前model的結構，如果建立起AddEName後，又改變了model，可以再使用'Add-Migration 201204031603044_AddEName' 來重現建立。</p>\n<p>然後我們看一下新增加的程式碼AddEName，我們可以看到，他自動地幫我們產生了以下的結構，我們可以看到up那邊，如果up，就會將EName加入到欄位。</p>\n<pre class=\"brush: csharp;\">namespace MigrationsCodeDemo.Migrations\n{\n    using System.Data.Entity.Migrations;\n\n    public partial class AddEName : DbMigration\n    {\n        public override void Up()\n        {\n            AddColumn(\"ClientBasics\", \"EName\", c =&gt; c.String());\n        }\n\n        public override void Down()\n        {\n            DropColumn(\"ClientBasics\", \"EName\");\n        }\n    }\n}\n</pre>\n<p>如果我們再看一下，最初建立的InitalCreate檔案，這邊則是使用CreateTable，因為InitalCreate是最原始的資料庫快照。</p>\n<pre class=\"brush: csharp;\">namespace MigrationsCodeDemo.Migrations\n{\n    using System.Data.Entity.Migrations;\n\n    public partial class InitialCreate : DbMigration\n    {\n        public override void Up()\n        {\n            CreateTable(\n                \"ClientBasics\",\n                c =&gt; new\n                    {\n                        ClientBasicId = c.Int(nullable: false, identity: true),\n                        Name = c.String(),\n                    })\n                .PrimaryKey(t =&gt; t.ClientBasicId);\n\n        }\n\n        public override void Down()\n        {\n            DropTable(\"ClientBasics\");\n        }\n    }\n}\n\n</pre>\n<p>其實到這邊，我們就可以完全的知道工作的原理了，我們有一個最原始的InitalCreate，而如果今天新增加一些欄位，就會有對應的Migration檔案來對應，所以當要增加欄位的時候，透過這種方法，就能解決原本Entity Framework不能新增欄位的問題了。</p>\n<p>最後我們要使用最後一個指令Update-Database!利用這個指令就可以順利的將EName欄位新增上去。</p>\n<p><a href=\"http://lh3.ggpht.com/-DLflYFL-MYk/T3snIyJAUII/AAAAAAAAB_Y/iBL-GZw9fXc/s1600-h/image%25255B26%25255D.png\"><img src=\"http://lh6.ggpht.com/-Pf_7BPZUu9c/T3snKLD6zdI/AAAAAAAAB_g/cZppT2dJQs8/image_thumb%25255B12%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>我們可以看到，多增加了一個EName的欄位!</p>\n<p><a href=\"http://lh4.ggpht.com/-5bgQuDh7_P8/T3snLAp4OOI/AAAAAAAAB_o/FawAN6Vjm1E/s1600-h/image%25255B33%25255D.png\"><img src=\"http://lh4.ggpht.com/-40zCygVBzy0/T3snMflDttI/AAAAAAAAB_w/IMgq9Zpm5DI/image_thumb%25255B15%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>而且，原本的資料，完全不會被砍掉。</p>\n<p><a href=\"http://lh4.ggpht.com/--vbN8R8QzgI/T3snNcBzzHI/AAAAAAAAB_0/0zmpr3A5dzo/s1600-h/image%25255B34%25255D.png\"><img src=\"http://lh4.ggpht.com/-df6W8UNZuBY/T3snOQ4LD_I/AAAAAAAAB_8/QOJrKUbTtAs/image_thumb%25255B16%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<p>以上是手動遷移，但其實Entity Framework也支援自動遷移，只需要在Package Manager Console下一個指令，Enable-Migrations –EnableAutomaticMigrations，就可以了。</p>\n<p>或是去Configuration.cs檔案裡面，把AutomaticMigrationsEnabled = fales的地方改成true也是可以，如下。</p>\n<pre class=\"brush: csharp;\">public Configuration()\n{\n    AutomaticMigrationsEnabled = true;\n}\n</pre>\n<p>這樣子，就可以直接下update-database來更新資料庫，而不用建立變更紀錄。</p>\n<h4>後記</h4>\n<p>其實到最後，原本的資料不會被砍掉，就可以發現到，它的原理並非是把整個Table Drop掉，而是用加上去的方式，而也利用這種方法來解決原本EF不能新增欄位的問題，也大大的加強了彈性，雖然整篇文章看起來很多，但實作一次後，一點也不會覺得困難!</p>\n<h4>參考資料</h4>\n<ul>\n<li><a href=\"http://blogs.msdn.com/b/adonet/archive/2012/02/09/ef-4-3-code-based-migrations-walkthrough.aspx\" title=\"http://blogs.msdn.com/b/adonet/archive/2012/02/09/ef-4-3-code-based-migrations-walkthrough.aspx\">http://blogs.msdn.com/b/adonet/archive/2012/02/09/ef-4-3-code-based-migrations-walkthrough.aspx</a></li>\n</ul>","excerpt":"上一篇提到Code First，也提到了一個問題，這個問題就是，如果我們在第一次使用Code First並建立好資料庫，但如果第二次需要增加個資料欄位，該怎麼辦?如果是以前，只能很無奈地把db刪除掉，然後在執行一次，但自從Entity Framework 4.…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"Windows Azure -  開啟雲上的IntelliTrace，以利偵錯!","tags":["Azure","Visual Studio"]},"fields":{"slug":"/2012/04/03/Windows-Azure-開啟雲上的IntelliTrace，以利偵錯/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/Windows-Azure-開啟雲上的IntelliTrace，以利偵錯.md"},"previous":{"frontmatter":{"path":null,"title":"SQL Server Data Tools 與 Visual Studio Achievements的Bug","tags":["NuGet","SQL Server","Tools","Visual Studio"]},"fields":{"slug":"/2012/04/05/SQL-Server-Data-Tools-與-Visual-Studio-Achievements的Bug/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/SQL-Server-Data-Tools-與-Visual-Studio-Achievements的Bug.md"}}}}