{"componentChunkName":"component---src-templates-page-js","path":"/2012/03/19/Prism-體會Shell和Module/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Prism - 體會Shell和Module","date":"19 March 2012","author":"Sky Chang","excerpt":null,"tags":["Silveright","WPF"],"coverImage":null},"id":"67de604b-026f-5095-bd4a-28638c131f44","html":"<p>這篇的內容，主要是翻譯於這個<a href=\"http://www.codeproject.com/Articles/155835/Prism-for-Silverlight-MEF-in-Easy-Samples-Part-1-P\">網站的內容</a>，是由國外的<strong><a href=\"http://www.codeproject.com/script/Membership/View.aspx?mid=2514552\">Nick Polyak</a></strong>高手所寫的，然後再加上小弟雜多的解釋內容XDD，所以內容不是百分百和原網站一樣，也請各位多多包涵 ( 所以這篇可以算是讀後心得了，不算翻譯文了.. )</p>\n<h4>最簡單!有xaml的Prism程式</h4>\n<p>上一篇，示範了完全沒有xmal的程式，利用完全沒有xaml的程式來專注於<code class=\"language-text\">Bootstrapper</code>上；而這篇，會示範一個最簡單，有xaml、Shell、Module的Prism程式，如果沒看過<a href=\"http://blog.sanc.idv.tw/2012/03/prism-prism.html\">前篇</a>，建議看一下會比較好，因為有很多的細節( 例如:Module專案怎麼建、要參考那些dll，有些不要copy local)的設定，不會再這一篇出現了。</p>\n<p>什麼叫做最簡單呢!?運作出來的結果如下，我們可以看到畫面非常的單純( 和上一篇比，至少有字了 )，只有兩串字，最上面是整個Shell，而中間紅色的字，則是利用Prism嵌入進來的Module1。</p>\n<p><a href=\"http://lh4.ggpht.com/-OQgd9RjMJaQ/T2dGHcCbwHI/AAAAAAAABsA/kcbOf-KhmL8/s1600-h/image9.png\"><img src=\"http://lh5.ggpht.com/-AkThtIya15g/T2dGIwNOcwI/AAAAAAAABsI/kJfE9gUH3dA/image_thumb5.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<h4>Shell</h4>\n<p>Shell在Prism裡面，就像一個重劃區土地一樣，負責提供最底層的地；而地裡面會再區分一個又一個的Region，每個Region上面就可以把Module蓋上去，就像是蓋個新光、大遠百之類的建築物。</p>\n<h4>Shell和Module的XAML</h4>\n<p>開始前，我們會先把放置Shell的Main Project和放置Module的Module Project準備好；當建立這兩個專案後，預設每個專案一定都會有一個MainPage.xaml，而這邊，我們分別把這兩個專案的MainPage.xaml改名，Main Project的部分，當然是改成Shell.xaml嚕，而Module的部分，就改成Module1View.xaml ( 再次提醒，如果沒看過<a href=\"http://blog.sanc.idv.tw/2012/03/prism-prism.html\">前篇</a>的人，建議看一下，因為有很多的細節需要處理。 )；而下面是先列出Shell和Module的XAML，以下是Shell的部分，我們可以看到，其實沒有多大的變化，只是我們多增加了prism的namespace，並且在ContentControl裡面，定義了MyRegion1的Region Name。</p>\n<pre class=\"brush: xml;\">&lt;UserControl x:Class=\"PrismDemo2HaveVisual.Shell\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    xmlns:prism=\"http://www.codeplex.com/prism\"&gt;\n\n    &lt;Grid x:Name=\"LayoutRoot\" Background=\"White\"&gt;\n        &lt;TextBlock Text=\"這裡是Shell,不是Module\"\n                   FontSize=\"25\"\n                   Foreground=\"Blue\"\n                   HorizontalAlignment=\"Center\"\n                   VerticalAlignment=\"Top\"/&gt;\n        &lt;!-- 放置Region，並給個名子--&gt;\n        &lt;ContentControl HorizontalAlignment=\"Center\"\n                        VerticalAlignment=\"Center\"\n                        prism:RegionManager.RegionName=\"MyRegion1\"/&gt;\n    &lt;/Grid&gt;\n&lt;/UserControl&gt;\n</pre>\n<p>接下來是Module的XAML，這部分就很簡單，裡面只放入一個TextBlock，其他沒甚麼改變。</p>\n<pre class=\"brush: xml;\">&lt;UserControl x:Class=\"Module1.Module1View\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"&gt;\n\n    &lt;TextBlock Text=\"我是Module1\"\n               FontSize=\"25\"\n               Foreground=\"Red\" \n               /&gt;\n&lt;/UserControl&gt;\n</pre>\n<p>接下來，我們來看看程式碼的部分。</p>\n<h4>Shell和Module的程式碼</h4>\n<p>Shell.cs的部分也很簡單，我們只要在Shell Class上面加上Export這個屬性，讓MEF知道要利用這個做輸出。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Animation;\nusing System.Windows.Shapes;\nusing System.ComponentModel.Composition;\n\nnamespace PrismDemo2HaveVisual\n{\n    [Export]\n    public partial class Shell : UserControl\n    {\n        public Shell()\n        {\n            InitializeComponent();\n        }\n    }\n}\n</pre>\n<p>接下來，我們看看Module的部分，這部分也只需要加上Export屬性。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Animation;\nusing System.Windows.Shapes;\nusing System.ComponentModel.Composition;\n\nnamespace Module1\n{\n    [Export(typeof(Module1View))]\n    public partial class Module1View : UserControl\n    {\n        public Module1View()\n        {\n            InitializeComponent();\n        }\n    }\n}\n</pre>\n<p>就這樣，就完成了視覺的部分。</p>\n<h4>建立Bootstapper Class</h4>\n<p>這個部份我相信大家應該都很有經驗了，大家可以直接看看下面的程式碼，比較特別的是ConfigureAggregateCatalog的方法裡面加了一行程式碼，我下面有很長的註解，如果看不太懂也沒關係，下一篇會針對原始碼做解說，這邊只要記住，是把Shell註冊進MEF就對了；其他部分則沒甚麼改變。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Net;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Documents;\nusing System.Windows.Ink;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Animation;\nusing System.Windows.Shapes;\nusing Microsoft.Practices.Prism.MefExtensions;\nusing System.ComponentModel.Composition.Hosting;\nusing Microsoft.Practices.Prism.Modularity;\n\nnamespace PrismDemo2HaveVisual\n{\n    public class TheBootstrapper : MefBootstrapper\n    {\n        protected override void InitializeShell()\n        {\n            base.InitializeShell();\n            //將Shell指定給Application的RootVisual，\n            //也就是說，此Application的最上層就是Shell了。\n            Application.Current.RootVisual = (UIElement) Shell;\n        }\n\n        protected override DependencyObject CreateShell()\n        {\n            //產生Shell。\n            return Container.GetExportedValue<shell>();\n        }\n\n        protected override void ConfigureAggregateCatalog()\n        {\n            base.ConfigureAggregateCatalog();\n\n            //這裡很有趣，AggregateCatalog這個變數是一個AggregateCatalog型別( 別懷疑，原始碼就是這樣，大小寫都一樣 )\n            //而我們這邊要多加一個AssemblyCatalog進去這個Collection裡面，\n            //而使用new AssemblyCatalog帶入的參數，會自動去搜尋這個Assembly裡面有符合的AssemblyCatalog，\n            //我們的目的就是希望把Shell加入進去。\n            //那為何用this呢?，因為這裡面就含有Shell( 也就是Shell.xaml.cs )，\n            //而這個Shell的程式碼裡面有Export，而這個Export就是這裡MEF需要的。\n            //但是Shell和這個類別好像沒關聯阿!?\n            //原因是因為this.GetType().Assembly這個地方，Assembly代表的是組件，\n            //換言之，他搜尋的層級並非只是這個Class.而是整個NameSpace的層級，\n            //剛好，好死不死，Shell和這個class的NameSpace是一樣的。\n\n            this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(this.GetType().Assembly));\n        }\n\n        protected override IModuleCatalog CreateModuleCatalog()\n        {\n            //最先進來\n            ModuleCatalog moduleCatalog = new ModuleCatalog();\n\n            //加入模組，這裡只是單純的加入模組，並不會決定放置的位置。\n            moduleCatalog.AddModule\n            (\n                new ModuleInfo\n                {\n                    InitializationMode = InitializationMode.WhenAvailable,\n                    Ref = \"Module1.xap\",\n                    ModuleName = \"Module1Impl\",\n                    ModuleType = \"Module1.Module1Impl, Module1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\n                }\n            );\n\n            return moduleCatalog;\n        }\n    }\n}\n</pre>\n<p>到這邊，Bootstrapper就算完成了。</p>\n<h4>更改App.xaml.cs</h4>\n<p>我們改用TheBootstrapper為主要的啟動物件。</p>\n<pre class=\"brush: csharp;\">private void Application_Startup(object sender, StartupEventArgs e)\n    {\n        (new TheBootstrapper()).Run();\n    }\n</pre>\n<p>最後，我們要建立一個實作IModule的物件。</p>\n<h4>建立實作IModule的物件Module1Impl</h4>\n<p>同樣的，我們最後必須建立一個實作IModule的物件，當此物件被建構的時候，會去利用MEF來注入一個實作IRegionManager的類別TheRegionManager，而在運作整個Prism的時候，並會利用TheRegionManager來將這個Module注入到Shell裡面的特定位置。</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Net;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Documents;\nusing System.Windows.Ink;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Animation;\nusing System.Windows.Shapes;\nusing Microsoft.Practices.Prism.Modularity;\nusing Microsoft.Practices.Prism.MefExtensions.Modularity;\nusing System.ComponentModel.Composition;\nusing Microsoft.Practices.Prism.Regions;\n\nnamespace Module1\n{\n    [ModuleExport(typeof(Module1Impl))]\n    public class Module1Impl : IModule\n    {\n\n        [Import]\n        public IRegionManager TheRegionManager { private get; set; }\n\n        #region IModule Members\n\n        public void Initialize()\n        {\n            //由外面傳進來的RegionManager，RegionManager用來控制此View要與哪個XAML的Region做關聯。\n            TheRegionManager.RegisterViewWithRegion(\"MyRegion1\", typeof(Module1View)); \n        }\n\n        #endregion\n    }\n}\n</pre>\n<p>就這樣，常常得撰寫過程後，就完成了，整個專案的文件夾，會如下圖。</p>\n<p><a href=\"http://lh4.ggpht.com/-cKFSEhAeeiQ/T2dGJ5ztFEI/AAAAAAAABsQ/O0WNdXff1fc/s1600-h/image%25255B3%25255D.png\"><img src=\"http://lh5.ggpht.com/-Sy5p3pMrPws/T2dGLOnNiHI/AAAAAAAABsY/pATc6R3f2Ac/image_thumb%25255B1%25255D.png?imgmax=800\" alt=\"image\" title=\"image\"></a></p>\n<h4>後記</h4>\n<p>如前面所說，Prism的入門比較高，但是好處卻是很大的，藉由Module的拆開，我們就可以很輕鬆地拆開來開發，而不會整個架構弄得亂七八糟，測試等等的流程，也會簡單許多，程式碼也會乾淨許多，但學習曲線是比較高的；最後，寫完這篇，或是看完這篇的人，或許還會有許多疑問，這時候，我們就準備要進入Bootstrapper的原始碼來看看了，下一篇，會介紹比較底層的架構，相信看完，會更加的了解，為什麼要這樣做。</p>\n<h4>參考資料</h4>\n<ul>\n<li>\n<p><a href=\"http://www.codeproject.com/Articles/155835/Prism-for-Silverlight-MEF-in-Easy-Samples-Part-1-P#Creating_App_Project\">http://www.codeproject.com/Articles/155835/Prism-for-Silverlight-MEF-in-Easy-Samples-Part-1-P#Creating<em>App</em>Project</a></p>\n<li>[http://msdn.microsoft.com/en-us/library/ff921153%28v=pandp.40%29.aspx](http://msdn.microsoft.com/en-us/library/ff921153%28v=pandp.40%29.aspx)\n</li>\n</ul>","excerpt":"這篇的內容，主要是翻譯於這個網站的內容，是由國外的Nick Polyak高手所寫的，然後再加上小弟雜多的解釋內容XDD，所以內容不是百分百和原網站一樣，也請各位多多包涵 ( 所以這篇可以算是讀後心得了，不算翻譯文了.. ) 最簡單!有xaml的Prism…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":null,"title":"Prism -  第一個!超簡單Prism範例","tags":["Silveright","WPF"]},"fields":{"slug":"/2012/03/18/Prism-第一個-超簡單Prism範例/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/Prism-第一個-超簡單Prism範例.md"},"previous":{"frontmatter":{"path":null,"title":"Windows 8 Consumer Preview Metro Style IE 不見了！","tags":["Firefox","Internet Explorer","Windows"]},"fields":{"slug":"/2012/03/22/Windows-8-Consumer-Preview-Metro-Style-IE-不見了！/"},"fileAbsolutePath":"/home/runner/work/blog.sanc.idv.tw/blog.sanc.idv.tw/src/posts/blog.sanc.idv.tw/Windows-8-Consumer-Preview-Metro-Style-IE-不見了！.md"}}}}